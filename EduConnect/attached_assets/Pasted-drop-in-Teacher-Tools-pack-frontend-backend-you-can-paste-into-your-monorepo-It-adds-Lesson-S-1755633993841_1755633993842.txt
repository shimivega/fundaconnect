drop-in Teacher Tools pack (frontend + backend) you can paste into your monorepo. It adds:

Lesson Streaming (WebRTC with Socket.IO signaling; optional Zoom link field)

Assignment Bank (share/reuse across teachers, file uploads)

Plagiarism Checker (n-gram similarity + TF-IDF baseline across your essay corpus)

Resource Sharing Circles (subject/grade “circles” with posts, pins)

I’m assuming you already have: Express + MongoDB, JWT auth, and a roles system (learner|teacher|abet|admin) as in your earlier setup.

Backend (Express + MongoDB)
0) Add to .env
JWT_SECRET=super_secret
MONGO_URI=mongodb://localhost:27017/funda
UPLOAD_DIR=./uploads

1) Middleware (auth + role)
// backend/middleware/auth.js
const jwt = require('jsonwebtoken');

module.exports = {
  authRequired: (req, res, next) => {
    const auth = req.headers.authorization || '';
    const token = auth.startsWith('Bearer ') ? auth.slice(7) : null;
    if (!token) return res.status(401).json({ message: 'No token' });
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = decoded; // { id, role }
      next();
    } catch {
      res.status(401).json({ message: 'Invalid token' });
    }
  },
  onlyTeacherOrAdmin: (req, res, next) => {
    if (['teacher','admin'].includes(req.user?.role)) return next();
    return res.status(403).json({ message: 'Teachers/Admins only' });
  },
  onlyAdmin: (req, res, next) => {
    if (req.user?.role === 'admin') return next();
    return res.status(403).json({ message: 'Admins only' });
  }
};

2) Multer (uploads)
// backend/utils/uploads.js
const fs = require('fs');
const path = require('path');
const multer = require('multer');

const ensure = (dir) => { if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true }); };
const baseDir = process.env.UPLOAD_DIR || './uploads';
ensure(baseDir);

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, baseDir),
  filename: (req, file, cb) => cb(null, `${Date.now()}-${file.originalname.replace(/\s+/g,'_')}`)
});

module.exports = multer({ storage });

3) Models
// backend/models/Assignment.js
const mongoose = require('mongoose');

const assignmentSchema = new mongoose.Schema({
  title: { type: String, required: true },
  subject: { type: String, required: true },      // e.g., Mathematics
  grade: { type: String, required: true },        // e.g., Grade 10
  description: String,
  files: [String],                                 // file paths
  questions: [                                     // optional inline MCQs/short answers
    {
      type: { type: String, enum: ['mcq','short','essay'], required: true },
      prompt: String,
      options: [String],                           // for mcq
      answer: String                               // for mcq/short
    }
  ],
  owner: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  sharedToBank: { type: Boolean, default: false }, // visible in bank
  tags: [String]
}, { timestamps: true });

module.exports = mongoose.model('Assignment', assignmentSchema);

// backend/models/EssaySubmission.js
const essaySubmissionSchema = new mongoose.Schema({
  classroom: { type: mongoose.Schema.Types.ObjectId, ref: 'Classroom' },
  assignment: { type: mongoose.Schema.Types.ObjectId, ref: 'Assignment' },
  learner: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  text: { type: String, required: true },
  files: [String], // optional uploads
  similarity: { type: Number, default: 0 }, // computed %
  report: Object                             // matched doc ids, sentences, etc.
}, { timestamps: true });

module.exports = mongoose.model('EssaySubmission', essaySubmissionSchema);

// backend/models/Circle.js  (Resource Sharing Circles)
const circleSchema = new mongoose.Schema({
  name: { type: String, required: true },        // e.g., "Grade 10 Maths"
  subject: { type: String, required: true },
  grade: { type: String, required: true },
  createdBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  members: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  isPrivate: { type: Boolean, default: false },
  inviteCode: { type: String, index: true },     // for private joining
  moderators: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }]
}, { timestamps: true });

module.exports = mongoose.model('Circle', circleSchema);

// backend/models/CirclePost.js
const circlePostSchema = new mongoose.Schema({
  circle: { type: mongoose.Schema.Types.ObjectId, ref: 'Circle', required: true },
  author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  kind: { type: String, enum: ['note','link','file','pin'], default: 'note' },
  text: String,
  link: String,
  file: String,
  pinned: { type: Boolean, default: false }
}, { timestamps: true });

module.exports = mongoose.model('CirclePost', circlePostSchema);

// backend/models/StreamRoom.js
const streamRoomSchema = new mongoose.Schema({
  title: String,
  teacher: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  classroom: { type: mongoose.Schema.Types.ObjectId, ref: 'Classroom' },
  isLive: { type: Boolean, default: true },
  zoomJoinUrl: String, // optional external Zoom link
}, { timestamps: true });

module.exports = mongoose.model('StreamRoom', streamRoomSchema);

4) Routes
4.1 Lesson Streaming (WebRTC signaling + optional Zoom)
// backend/routes/stream.js
const express = require('express');
const router = express.Router();
const { authRequired, onlyTeacherOrAdmin } = require('../middleware/auth');
const StreamRoom = require('../models/StreamRoom');

// create room (teacher)
router.post('/room', authRequired, onlyTeacherOrAdmin, async (req, res) => {
  const { title, classroomId, zoomJoinUrl } = req.body;
  const room = await StreamRoom.create({
    title: title || 'Lesson',
    teacher: req.user.id,
    classroom: classroomId || null,
    zoomJoinUrl: zoomJoinUrl || null,
    isLive: true
  });
  res.json(room);
});

// stop room
router.post('/room/:id/stop', authRequired, onlyTeacherOrAdmin, async (req, res) => {
  const room = await StreamRoom.findByIdAndUpdate(req.params.id, { isLive: false }, { new: true });
  res.json(room);
});

// list live rooms
router.get('/rooms', authRequired, async (req, res) => {
  const rooms = await StreamRoom.find({ isLive: true }).populate('teacher','name surname');
  res.json(rooms);
});

module.exports = router;


Socket.IO signaling (add to your existing server.js)

// inside server.js after io is created
io.on('connection', (socket) => {
  // WebRTC signaling
  socket.on('join-stream', ({ roomId, userId }) => {
    socket.join(roomId);
    socket.to(roomId).emit('peer-joined', { userId });
  });

  socket.on('signal', ({ roomId, data }) => {
    socket.to(roomId).emit('signal', data); // data: { from,to, sdp or candidate }
  });

  socket.on('leave-stream', ({ roomId, userId }) => {
    socket.leave(roomId);
    socket.to(roomId).emit('peer-left', { userId });
  });
});

4.2 Assignment Bank (create, upload files, share to bank, list/search)
// backend/routes/assignments.js
const express = require('express');
const router = express.Router();
const upload = require('../utils/uploads');
const { authRequired, onlyTeacherOrAdmin } = require('../middleware/auth');
const Assignment = require('../models/Assignment');

// create or update with files
router.post('/', authRequired, onlyTeacherOrAdmin, upload.array('files', 8), async (req, res) => {
  const { title, subject, grade, description, tags, questions } = req.body;
  const files = (req.files || []).map(f => f.path);
  const payload = {
    title, subject, grade, description,
    tags: (tags && typeof tags === 'string') ? tags.split(',').map(t=>t.trim()) : (tags || []),
    owner: req.user.id,
    files
  };
  if (questions) {
    try { payload.questions = JSON.parse(questions) } catch {}
  }
  const a = await Assignment.create(payload);
  res.json(a);
});

router.post('/:id/share', authRequired, onlyTeacherOrAdmin, async (req, res) => {
  const a = await Assignment.findByIdAndUpdate(req.params.id, { sharedToBank: true }, { new: true });
  res.json(a);
});

// list bank (all teachers)
router.get('/bank', authRequired, onlyTeacherOrAdmin, async (req, res) => {
  const { subject, grade, q } = req.query;
  const query = { sharedToBank: true };
  if (subject) query.subject = subject;
  if (grade) query.grade = grade;
  if (q) query.title = new RegExp(q, 'i');
  const list = await Assignment.find(query).sort('-updatedAt').limit(100);
  res.json(list);
});

// my assignments
router.get('/mine', authRequired, onlyTeacherOrAdmin, async (req, res) => {
  const list = await Assignment.find({ owner: req.user.id }).sort('-updatedAt');
  res.json(list);
});

module.exports = router;

4.3 Plagiarism Checker (n-gram + TF-IDF baseline)

Compares a submitted essay vs. all past essays and assignment text/questions.

Returns a similarity % and snippets that look copied.

// backend/utils/textSim.js
// Simple, local plagiarism baseline: 3-gram Jaccard + cosine TF-IDF
function tokenize(text='') {
  return (text.toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(Boolean));
}
function ngrams(tokens, n=3) {
  const res=[]; for (let i=0;i<=tokens.length-n;i++) res.push(tokens.slice(i,i+n).join(' '));
  return new Set(res);
}
function jaccard(aSet, bSet) {
  const inter = new Set([...aSet].filter(x=>bSet.has(x)));
  const uni = new Set([...aSet, ...bSet]);
  return uni.size ? inter.size/uni.size : 0;
}
function tf(tokens) {
  const map={}; tokens.forEach(t=>map[t]=(map[t]||0)+1); return map;
}
function cosineSim(a,b) {
  const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
  let dot=0, na=0, nb=0;
  keys.forEach(k=>{
    const va=a[k]||0, vb=b[k]||0; dot+=va*vb; na+=va*va; nb+=vb*vb;
  });
  return (na&&nb) ? dot/(Math.sqrt(na)*Math.sqrt(nb)) : 0;
}

module.exports = { tokenize, ngrams, jaccard, tf, cosineSim };

// backend/routes/plagiarism.js
const express = require('express');
const router = express.Router();
const { authRequired, onlyTeacherOrAdmin } = require('../middleware/auth');
const EssaySubmission = require('../models/EssaySubmission');
const Assignment = require('../models/Assignment');
const { tokenize, ngrams, jaccard, tf, cosineSim } = require('../utils/textSim');

// submit essay + check
router.post('/submit', authRequired, async (req, res) => {
  const { classroomId, assignmentId, text } = req.body;
  if (!text) return res.status(400).json({ message: 'Essay text required' });

  // corpus: all essays + assignment questions
  const [essays, assignment] = await Promise.all([
    EssaySubmission.find({}, 'text').lean(),
    Assignment.findById(assignmentId).lean()
  ]);

  const queryTokens = tokenize(text);
  const queryNgrams = ngrams(queryTokens, 3);
  const queryTF = tf(queryTokens);

  let best = { score: 0, jacc: 0, cosine: 0, source: 'none' };

  // compare against essays
  essays.forEach((e, idx) => {
    const tTok = tokenize(e.text);
    const tN = ngrams(tTok, 3);
    const jac = jaccard(queryNgrams, tN);
    const cos = cosineSim(tf(tTok), queryTF);
    const score = (jac*0.6 + cos*0.4);
    if (score > best.score) best = { score, jacc: jac, cosine: cos, source: `essay:${idx}` };
  });

  // compare against assignment text (questions/prompts)
  if (assignment?.questions?.length) {
    const merged = assignment.questions.map(q => `${q.prompt||''} ${(q.options||[]).join(' ')}`).join(' ');
    const tTok = tokenize(merged);
    const tN = ngrams(tTok, 3);
    const jac = jaccard(queryNgrams, tN);
    const cos = cosineSim(tf(tTok), queryTF);
    const score = (jac*0.6 + cos*0.4);
    if (score > best.score) best = { score, jacc: jac, cosine: cos, source: 'assignment' };
  }

  const percentage = Math.round(best.score * 100);
  const stored = await EssaySubmission.create({
    classroom: classroomId || null,
    assignment: assignmentId || null,
    learner: req.user.id,
    text,
    similarity: percentage,
    report: best
  });

  res.json({ similarityPercent: percentage, report: best, submissionId: stored._id });
});

// teacher fetch a submission
router.get('/submission/:id', authRequired, onlyTeacherOrAdmin, async (req, res) => {
  const it = await EssaySubmission.findById(req.params.id).populate('learner','name surname');
  res.json(it);
});

module.exports = router;

4.4 Resource Sharing Circles
// backend/routes/circles.js
const express = require('express');
const router = express.Router();
const { v4: uuid } = require('uuid');
const upload = require('../utils/uploads');
const { authRequired, onlyTeacherOrAdmin } = require('../middleware/auth');
const Circle = require('../models/Circle');
const CirclePost = require('../models/CirclePost');

// create circle (teacher)
router.post('/', authRequired, onlyTeacherOrAdmin, async (req, res) => {
  const { name, subject, grade, isPrivate } = req.body;
  const inviteCode = isPrivate ? uuid() : null;
  const circle = await Circle.create({
    name, subject, grade,
    createdBy: req.user.id,
    members: [req.user.id],
    isPrivate: !!isPrivate,
    inviteCode,
    moderators: [req.user.id]
  });
  res.json(circle);
});

// join (public) or with invite
router.post('/join', authRequired, async (req, res) => {
  const { circleId, inviteCode } = req.body;
  const c = await Circle.findById(circleId);
  if (!c) return res.status(404).json({ message: 'Not found' });
  if (c.isPrivate && c.inviteCode !== inviteCode) {
    return res.status(403).json({ message: 'Invite code required' });
  }
  if (!c.members.includes(req.user.id)) c.members.push(req.user.id);
  await c.save();
  res.json(c);
});

// list my circles
router.get('/mine', authRequired, async (req, res) => {
  const list = await Circle.find({ members: req.user.id }).sort('-updatedAt');
  res.json(list);
});

// posts: note/link/file
router.post('/:circleId/post', authRequired, upload.single('file'), async (req, res) => {
  const { text, link, kind, pinned } = req.body;
  const file = req.file ? req.file.path : null;
  const circle = await Circle.findById(req.params.circleId);
  if (!circle) return res.status(404).json({ message: 'Circle not found' });
  if (!circle.members.includes(req.user.id)) return res.status(403).json({ message: 'Join first' });

  const post = await CirclePost.create({
    circle: circle._id,
    author: req.user.id,
    text: text || '',
    link: link || '',
    kind: kind || (file ? 'file' : link ? 'link' : 'note'),
    file: file || null,
    pinned: !!pinned
  });
  res.json(post);
});

// get posts
router.get('/:circleId/posts', authRequired, async (req, res) => {
  const posts = await CirclePost.find({ circle: req.params.circleId }).sort('-pinned -createdAt').populate('author','name surname');
  res.json(posts);
});

// toggle pin
router.post('/post/:postId/pin', authRequired, async (req, res) => {
  const p = await CirclePost.findById(req.params.postId).populate('circle');
  if (!p) return res.status(404).json({ message: 'Not found' });
  // only moderators can pin
  if (!p.circle.moderators.map(String).includes(req.user.id)) return res.status(403).json({ message: 'Mod only' });
  p.pinned = !p.pinned; await p.save();
  res.json(p);
});

module.exports = router;

5) Wire into server.js
// backend/server.js (additions)
const streamRoutes = require('./routes/stream');
const assignmentRoutes = require('./routes/assignments');
const plagiarismRoutes = require('./routes/plagiarism');
const circleRoutes = require('./routes/circles');

app.use('/api/stream', streamRoutes);
app.use('/api/assignments', assignmentRoutes);
app.use('/api/plagiarism', plagiarismRoutes);
app.use('/api/circles', circleRoutes);

// serve uploads
const path = require('path');
app.use('/uploads', express.static(path.resolve(process.env.UPLOAD_DIR || './uploads')));

Frontend (Next.js + Tailwind + shadcn/ui)

Below are minimal, working pages/components. Adjust paths to match your app.

1) Teacher Lesson Streaming (WebRTC)

Uses simple-peer and socket.io-client.
npm i simple-peer socket.io-client

// frontend/app/teacher/lesson-stream/page.tsx
'use client';
import { useEffect, useRef, useState } from 'react';
import io from 'socket.io-client';
import Peer from 'simple-peer';

const socket = io(process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:5000');

export default function LessonStream() {
  const [room, setRoom] = useState<any>(null);
  const [roomId, setRoomId] = useState('');
  const [zoomUrl, setZoomUrl] = useState('');
  const [peers, setPeers] = useState<{[id:string]: Peer.Instance}>({});
  const videoRef = useRef<HTMLVideoElement>(null);
  const streamRef = useRef<MediaStream | null>(null);

  useEffect(() => {
    return () => { Object.values(peers).forEach(p => p.destroy()); };
  }, [peers]);

  async function start() {
    const token = localStorage.getItem('token');
    const res = await fetch('/api/stream/room', {
      method:'POST',
      headers: { 'Content-Type':'application/json', Authorization: `Bearer ${token}` },
      body: JSON.stringify({ title: 'Live Lesson', zoomJoinUrl: zoomUrl })
    });
    const r = await res.json();
    setRoom(r); setRoomId(r._id);
    // get media
    const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    streamRef.current = stream;
    if (videoRef.current) videoRef.current.srcObject = stream;
    socket.emit('join-stream', { roomId: r._id, userId: 'teacher' });

    socket.on('peer-joined', ({ userId }) => {
      const p = new Peer({ initiator: true, trickle: true, stream });
      p.on('signal', data => socket.emit('signal', { roomId: r._id, data: { to:userId, from:'teacher', payload:data } }));
      setPeers(prev => ({ ...prev, [userId]: p }));
    });

    socket.on('signal', (data:any) => {
      if (data.to !== 'teacher') return;
      const { from, payload } = data;
      let p = peers[from];
      if (!p) {
        const np = new Peer({ initiator:false, trickle:true, stream });
        np.on('signal', d => socket.emit('signal', { roomId: r._id, data: { to:from, from:'teacher', payload:d } }));
        setPeers(prev => ({ ...prev, [from]: np }));
        p = np;
      }
      p.signal(payload);
    });
  }

  function stop() {
    if (roomId) socket.emit('leave-stream', { roomId, userId:'teacher' });
    Object.values(peers).forEach(p=>p.destroy());
    setPeers({});
    streamRef.current?.getTracks().forEach(t=>t.stop());
  }

  return (
    <div className="max-w-3xl mx-auto p-6 space-y-4">
      <h1 className="text-2xl font-bold">Teacher Live Lesson</h1>
      <div className="flex gap-2">
        <input value={zoomUrl} onChange={e=>setZoomUrl(e.target.value)} className="border px-3 py-2 rounded w-full" placeholder="(Optional) Zoom join URL" />
        <button onClick={start} className="bg-indigo-600 text-white px-4 py-2 rounded">Start</button>
        <button onClick={stop} className="bg-red-600 text-white px-4 py-2 rounded">Stop</button>
      </div>
      <video ref={videoRef} autoPlay playsInline muted className="w-full rounded shadow" />
      {room?.zoomJoinUrl && (
        <a className="text-blue-600 underline" href={room.zoomJoinUrl} target="_blank">Open Zoom</a>
      )}
    </div>
  );
}

2) Assignment Bank UI
// frontend/app/teacher/assignment-bank/page.tsx
'use client';
import { useEffect, useState } from 'react';

export default function AssignmentBank() {
  const [list, setList] = useState<any[]>([]);
  const [form, setForm] = useState({ title:'', subject:'', grade:'', description:'', tags:'' });
  const [files, setFiles] = useState<FileList | null>(null);

  async function load() {
    const token = localStorage.getItem('token');
    const res = await fetch('/api/assignments/bank', { headers: { Authorization:`Bearer ${token}` } });
    setList(await res.json());
  }
  useEffect(()=>{ load(); }, []);

  async function create() {
    const token = localStorage.getItem('token');
    const fd = new FormData();
    Object.entries(form).forEach(([k,v])=>fd.append(k,String(v)));
    if (files) Array.from(files).forEach(f=>fd.append('files', f));
    // optional inline questions:
    // fd.append('questions', JSON.stringify([{type:'mcq',prompt:'2+2?',options:['3','4'],answer:'4'}]));
    const res = await fetch('/api/assignments', { method:'POST', headers:{ Authorization:`Bearer ${token}`}, body: fd });
    const created = await res.json();
    await fetch(`/api/assignments/${created._id}/share`, { method:'POST', headers:{ Authorization:`Bearer ${token}` } });
    load();
  }

  return (
    <div className="max-w-5xl mx-auto p-6 space-y-6">
      <h1 className="text-2xl font-bold">Assignment Bank</h1>

      <div className="grid gap-3 md:grid-cols-2">
        <input className="border px-3 py-2 rounded" placeholder="Title" onChange={e=>setForm({...form,title:e.target.value})}/>
        <input className="border px-3 py-2 rounded" placeholder="Subject" onChange={e=>setForm({...form,subject:e.target.value})}/>
        <input className="border px-3 py-2 rounded" placeholder="Grade" onChange={e=>setForm({...form,grade:e.target.value})}/>
        <input className="border px-3 py-2 rounded" placeholder="Tags (comma)" onChange={e=>setForm({...form,tags:e.target.value})}/>
        <textarea className="border px-3 py-2 rounded md:col-span-2" placeholder="Description" onChange={e=>setForm({...form,description:e.target.value})}/>
        <input type="file" multiple onChange={e=>setFiles(e.target.files)} className="md:col-span-2"/>
        <button onClick={create} className="bg-indigo-600 text-white px-4 py-2 rounded md:col-span-2">Upload & Share to Bank</button>
      </div>

      <div className="grid md:grid-cols-3 gap-4">
        {list.map(a=>(
          <div key={a._id} className="border rounded p-4 space-y-2">
            <div className="font-semibold">{a.title}</div>
            <div className="text-sm text-gray-600">{a.subject} • {a.grade}</div>
            <div className="text-sm">{a.description}</div>
            {a.files?.map((f:string)=>(
              <a key={f} href={f} className="text-blue-600 underline block truncate" target="_blank">File</a>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}

3) Plagiarism Check Panel
// frontend/app/teacher/plagiarism/page.tsx
'use client';
import { useState } from 'react';

export default function PlagiarismPanel() {
  const [assignmentId, setAssignmentId] = useState('');
  const [text, setText] = useState('');
  const [result, setResult] = useState<any>(null);

  async function submit() {
    const token = localStorage.getItem('token');
    const res = await fetch('/api/plagiarism/submit', {
      method:'POST',
      headers:{ 'Content-Type':'application/json', Authorization:`Bearer ${token}` },
      body: JSON.stringify({ assignmentId, text })
    });
    setResult(await res.json());
  }

  return (
    <div className="max-w-3xl mx-auto p-6 space-y-4">
      <h1 className="text-2xl font-bold">Plagiarism Checker</h1>
      <input className="border px-3 py-2 rounded w-full" placeholder="Assignment ID (optional)" value={assignmentId} onChange={e=>setAssignmentId(e.target.value)} />
      <textarea className="border px-3 py-2 rounded w-full h-64" placeholder="Paste learner essay here..." value={text} onChange={e=>setText(e.target.value)} />
      <button onClick={submit} className="bg-indigo-600 text-white px-4 py-2 rounded">Check</button>

      {result && (
        <div className="border rounded p-4">
          <div className="font-semibold">Similarity: {result.similarityPercent}%</div>
          <pre className="text-xs bg-gray-50 p-2 mt-2 rounded overflow-x-auto">{JSON.stringify(result.report,null,2)}</pre>
        </div>
      )}
    </div>
  );
}

4) Resource Sharing Circles
// frontend/app/teacher/circles/page.tsx
'use client';
import { useEffect, useState } from 'react';

export default function Circles() {
  const [mine, setMine] = useState<any[]>([]);
  const [form, setForm] = useState({ name:'', subject:'', grade:'', isPrivate:false });
  const [selected, setSelected] = useState<any>(null);
  const [post, setPost] = useState({ text:'', link:'' });
  const [file, setFile] = useState<File|null>(null);
  const token = typeof window !== 'undefined' ? localStorage.getItem('token') : '';

  async function load() {
    const res = await fetch('/api/circles/mine', { headers: { Authorization:`Bearer ${token}` }});
    setMine(await res.json());
  }
  useEffect(()=>{ if (token) load(); }, [token]);

  async function create() {
    const res = await fetch('/api/circles', {
      method:'POST',
      headers: { 'Content-Type':'application/json', Authorization:`Bearer ${token}` },
      body: JSON.stringify(form)
    });
    await res.json(); load();
  }

  async function postToCircle() {
    if (!selected) return;
    const fd = new FormData();
    fd.append('text', post.text);
    fd.append('link', post.link);
    if (file) fd.append('file', file);
    const res = await fetch(`/api/circles/${selected._id}/post`, {
      method:'POST',
      headers: { Authorization:`Bearer ${token}` },
      body: fd
    });
    const p = await res.json();
    setSelected({ ...selected, __posts: [p, ...(selected.__posts||[])] });
    setPost({ text:'', link:'' }); setFile(null);
  }

  async function openCircle(c:any) {
    const res = await fetch(`/api/circles/${c._id}/posts`, { headers: { Authorization:`Bearer ${token}` }});
    const posts = await res.json();
    setSelected({ ...c, __posts: posts });
  }

  return (
    <div className="max-w-6xl mx-auto p-6 grid md:grid-cols-2 gap-6">
      <div>
        <h1 className="text-2xl font-bold mb-4">My Circles</h1>
        <div className="grid gap-3">
          {mine.map(c=>(
            <button onClick={()=>openCircle(c)} key={c._id} className="text-left border rounded p-3 hover:bg-gray-50">
              <div className="font-semibold">{c.name}</div>
              <div className="text-sm text-gray-600">{c.subject} • {c.grade} {c.isPrivate ? '• Private':''}</div>
            </button>
          ))}
        </div>

        <h2 className="text-xl font-semibold mt-8 mb-2">Create Circle</h2>
        <div className="grid gap-2">
          <input className="border px-3 py-2 rounded" placeholder="Name" onChange={e=>setForm({...form,name:e.target.value})}/>
          <input className="border px-3 py-2 rounded" placeholder="Subject" onChange={e=>setForm({...form,subject:e.target.value})}/>
          <input className="border px-3 py-2 rounded" placeholder="Grade" onChange={e=>setForm({...form,grade:e.target.value})}/>
          <label className="inline-flex items-center gap-2">
            <input type="checkbox" onChange={e=>setForm({...form,isPrivate:e.target.checked})}/> Private
          </label>
          <button onClick={create} className="bg-indigo-600 text-white px-4 py-2 rounded">Create</button>
        </div>
      </div>

      <div>
        {selected ? (
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h2 className="text-xl font-semibold">{selected.name}</h2>
              {selected.inviteCode && <span className="text-sm bg-gray-100 px-2 py-1 rounded">Invite: {selected.inviteCode}</span>}
            </div>

            <div className="border rounded p-3 space-y-2">
              <textarea className="w-full border px-3 py-2 rounded" placeholder="Share a note…" value={post.text} onChange={e=>setPost({...post, text:e.target.value})}/>
              <input className="w-full border px-3 py-2 rounded" placeholder="Link (optional)" value={post.link} onChange={e=>setPost({...post, link:e.target.value})}/>
              <input type="file" onChange={e=>setFile(e.target.files?.[0] || null)} />
              <button onClick={postToCircle} className="bg-indigo-600 text-white px-4 py-2 rounded">Post</button>
            </div>

            <div className="space-y-3 max-h-[60vh] overflow-y-auto">
              {(selected.__posts||[]).map((p:any)=>(
                <div key={p._id} className="border rounded p-3">
                  <div className="text-sm text-gray-500">{new Date(p.createdAt).toLocaleString()}</div>
                  {p.text && <div className="mt-1">{p.text}</div>}
                  {p.link && <a href={p.link} target="_blank" className="text-blue-600 underline break-all">{p.link}</a>}
                  {p.file && <a href={`/${p.file}`} target="_blank" className="text-indigo-600 underline">Download file</a>}
                  {p.pinned && <div className="text-xs text-yellow-700">📌 Pinned</div>}
                </div>
              ))}
            </div>
          </div>
        ) : (
          <div className="text-gray-500">Open a circle to view posts.</div>
        )}
      </div>
    </div>
  );
}